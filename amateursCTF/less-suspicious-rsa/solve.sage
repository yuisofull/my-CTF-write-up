load('coppersmith.sage')
def factorial(n):
    if n == 0:
        return 1
    return factorial(n-1) * n
n=factorial(90)
N=138963980427736364646203557164328211078134463518489686365728312873583832517087170768576679472472907142081360480944201759920246566585465801088226164314480607014663211599932950864391702460227584467326051919881067028851940610382044445003060103566003934601979805899293539507221062915314813557293919231917284247667
e=65537
c= 26363325527372681448374836719361674028908733933823971039273016094221739663363697355984980560218941405351917768372297139270315950803631724328547161889191685480725185971092638691575587334307068143724069148715129866085595445974433311000459043513392513632639058879350662222598941781017396217632160254074487773693
from Crypto.Util.number import *
from Crypto.Util.number import long_to_bytes

r=553735493247344589480196843778770598010794541635041072541668315290019942255486404490895178599773616388310946265041525293919231917284247667

lbits=500
while True:
    ln = 2^lbits
    p_length=512
    q_length=1044

    X = Y = 2^(lbits+2) # bounds on x0 and y0


    bounds = (X,Y)
    R = Integers(N)
    PR.<x, y> = PolynomialRing(Zmod(N))

    f = (x*n+r)*(y*n+1)

    ok=small_roots(f, bounds)
    if ok == [] or ok == [(0, 0)]:
        lbits = lbits + 1
        continue
    print(small_roots(f, bounds))

    print("p = ", ok[0][0]*n+r)
    p=ok[0][0]*n+r
        
    break

q=int(N/p)
d = pow(e, -1, (p-1)*(q-1))
m = pow(c, d, N)
from Crypto.Util.number import *
print(long_to_bytes(int(m)))