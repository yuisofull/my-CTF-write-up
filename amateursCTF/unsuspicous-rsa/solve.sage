load('coppersmith.sage')
def factorial(n):
    if n == 0:
        return 1
    return factorial(n-1) * n
n=factorial(90)
N=172391551927761576067659307357620721422739678820495774305873584621252712399496576196263035396006999836369799931266873378023097609967946749267124740589901094349829053978388042817025552765214268699484300142561454883219890142913389461801693414623922253012031301348707811702687094437054617108593289186399175149061
e=65537
c= 128185847052386409377183184214572579042527531775256727031562496105460578259228314918798269412725873626743107842431605023962700973103340370786679287012472752872015208333991822872782385473020628386447897357839507808287989016150724816091476582807745318701830009449343823207792128099226593723498556813015444306241
from Crypto.Util.number import *
from Crypto.Util.number import long_to_bytes

r=1465206365218438988501871717367737721383407055421539184868199591090708510090421286509040233557605110129548909869110804593289186399175149061

lbits=500
# while True:
ln = 2^lbits
p_length=512
q_length=1044

X = Y = 2^(lbits+2) # bounds on x0 and y0


bounds = (X,Y)
R = Integers(N)
PR.<x, y> = PolynomialRing(Zmod(N))

f = (x*n + r)*(y*n+1)

ok=small_roots(f, bounds)
print(small_roots(f, bounds))

print("p = ", ok[0][0]*n + r)
p=ok[0][0]*n + r